
#pragma kernel BlendDynamicShadowsNearest   CSMain=BlendDynamicShadowsNearest   WITH_DYNAMIC_SHADOWS NEAREST_SAMPLE
#pragma kernel BlendDynamicShadowsBilinear  CSMain=BlendDynamicShadowsBilinear  WITH_DYNAMIC_SHADOWS BILINEAR_SAMPLE
#pragma kernel BlendDynamicShadowsTrilinear CSMain=BlendDynamicShadowsTrilinear WITH_DYNAMIC_SHADOWS TRILINEAR_SAMPLE

#pragma kernel NoBlendNearest               CSMain=NoBlendNearest               NEAREST_SAMPLE
#pragma kernel NoBlendBilinear              CSMain=NoBlendBilinear              BILINEAR_SAMPLE
#pragma kernel NoBlendTrilinear             CSMain=NoBlendTrilinear             TRILINEAR_SAMPLE

#define TILE_SIZE 8

#define _SHADOWS_ENABLED
#define _MAIN_LIGHT_SHADOWS_CASCADE


#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Input.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Shadows.hlsl"
#include "Packages/com.unity.voxelized-shadows/ShaderLibrary/Common.hlsl"

#ifdef UNITY_MATRIX_I_VP
#undef UNITY_MATRIX_I_VP
#endif


#define UNITY_MATRIX_I_VP _InvViewProjMatrix

#if defined(UNITY_STEREO_INSTANCING_ENABLED) || defined(UNITY_STEREO_MULTIVIEW_ENABLED)
TEXTURE2D_ARRAY_FLOAT(_CameraDepthTexture);
#else
TEXTURE2D_FLOAT(_CameraDepthTexture);
#endif

SAMPLER(sampler_CameraDepthTexture);

CBUFFER_START(_DirectionalVxShadowMap)
int _BeginOffset;
int _VoxelZBias;
float _VoxelUpBias;
CBUFFER_END

RW_TEXTURE2D(half, _ScreenSpaceShadowOutput);

#undef USE_EMULATE_COUNTBITS

uint countBits_(uint i)
{
#ifdef USE_EMULATE_COUNTBITS
    i = i - ((i >> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);

    return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
#else
    return countbits(i);
#endif
}

uint4 countBits_(uint4 i)
{
#ifdef USE_EMULATE_COUNTBITS
    i = i - ((i >> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);

    return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
#else
    return countbits(i);
#endif
}

void TraverseVxShadowMapPosQ_(uint begin, uint typeOffset, uint3 posQ, out uint4 result)
{
#if 1 //opt2
    uint vxsmOffset = begin + typeOffset;
    uint dagScale = _VxShadowMapsBuffer[begin + 2];

    uint scale = dagScale - 1;

    // calculate where to go to child
    uint3 childDet = ((posQ >> scale) & 0x00000001) << uint3(1, 2, 3);
    uint cellShift = childDet.x + childDet.y + childDet.z;
    uint cellbit   = 0x00000003 << cellShift;

    // initial access
    uint nodeIndex = 0;
    uint vxsmAccess = vxsmOffset;

    // calculate bit
    uint childmask = _VxShadowMapsBuffer[vxsmAccess] >> 16;
    uint shadowbit = (childmask & cellbit) >> cellShift;

    // determine whether it is intersected or not
    bool intersected = shadowbit == 0x00000003;

    uint mask = 0;
    uint childrenbit = 0;
    uint childIndex = 0;

    for (; scale > 3 && intersected; --scale)
    {
        // find next child node
        mask = ~(0xFFFFFFFF << cellShift);
        childrenbit = childmask & ((childmask & 0x0000AAAA) >> 1);
        childIndex = countBits_(childrenbit & mask);

        // update access
        vxsmAccess = vxsmAccess + 1 + childIndex;
        nodeIndex  = _VxShadowMapsBuffer[vxsmAccess];
        vxsmAccess = vxsmOffset + nodeIndex;

        // calculate where to go to child
        childDet  = ((posQ >> (scale - 1)) & 0x00000001) << uint3(1, 2, 3);
        cellShift = childDet.x + childDet.y + childDet.z;
        cellbit   = 0x00000003 << cellShift;

        // calculate bit
        childmask = _VxShadowMapsBuffer[vxsmAccess] >> 16;
        shadowbit = (childmask & cellbit) >> cellShift;

        // determine whether it is intersected or not
        intersected = shadowbit == 0x00000003;
    }

    // go further the rest of computation
    if (intersected)
    {
        mask = ~(0xFFFFFFFF << cellShift);
        childrenbit = childmask & ((childmask & 0x0000AAAA) >> 1);
        childIndex = countBits_(childrenbit & mask);

        vxsmAccess = vxsmAccess + 1 + childIndex;
        nodeIndex  = _VxShadowMapsBuffer[vxsmAccess + 1 + childIndex];
    }

    result = uint4(nodeIndex, shadowbit & 0x00000001, shadowbit & 0x00000002, intersected);
#else
    uint vxsmOffset = begin + typeOffset;
    uint dagScale = _VxShadowMapsBuffer[begin + 2];

    uint nodeIndex = 0;
    uint scale = dagScale;

    bool lit = false;
    bool shadowed = false;
    bool intersected = true;

    for (; scale > 3 && intersected; --scale)
    {
        // calculate where to go to child
        uint3 childDet = (posQ >> (scale - 1)) & 0x00000001;
        uint cellShift = (childDet.x << 1) + (childDet.y << 2) + (childDet.z << 3);
        uint cellbit   = 0x00000003 << cellShift;

        // calculate bit
        uint header = _VxShadowMapsBuffer[vxsmOffset + nodeIndex];
        uint childmask = header >> 16;
        uint shadowbit = (childmask & cellbit) >> cellShift;

        // determine whether it is lit or shadowed.
        lit      = shadowbit & 0x00000001;
        shadowed = shadowbit & 0x00000002;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        intersected = lit && shadowed;

        // find next child node
        uint mask = ~(0xFFFFFFFF << cellShift);
        uint childrenbit = childmask & ((childmask & 0x0000AAAA) >> 1);
        uint childIndex = countBits(childrenbit & mask);

        // go down to the next node
        nodeIndex = _VxShadowMapsBuffer[vxsmOffset + nodeIndex + 1 + childIndex];
    }

    result = uint4(nodeIndex, lit, shadowed, intersected);
#endif
}

void TraverseVxShadowMapPosQ2x2_(uint begin, uint typeOffset, uint3 posQ_0, out uint4 results[4])
{
#if 1//opt1
    uint vxsmOffset = begin + typeOffset;
    uint dagScale = _VxShadowMapsBuffer[begin + 2];

    uint3 posQ_1 = posQ_0 + uint3(1, 0, 0);
    uint3 posQ_2 = posQ_0 + uint3(0, 1, 0);
    uint3 posQ_3 = posQ_0 + uint3(1, 1, 0);

    uint scale = dagScale - 1;

    // calculate where to go to child
    uint3 childDet_0 = ((posQ_0 >> scale) & 0x00000001) << uint3(1, 2, 3);
    uint3 childDet_1 = ((posQ_1 >> scale) & 0x00000001) << uint3(1, 2, 3);
    uint3 childDet_2 = ((posQ_2 >> scale) & 0x00000001) << uint3(1, 2, 3);
    uint3 childDet_3 = ((posQ_3 >> scale) & 0x00000001) << uint3(1, 2, 3);
    uint4 cellShift4 = uint4(
        childDet_0.x + childDet_0.y + childDet_0.z,
        childDet_1.x + childDet_1.y + childDet_1.z,
        childDet_2.x + childDet_2.y + childDet_2.z,
        childDet_3.x + childDet_3.y + childDet_3.z);
    uint4 cellbit4 = 0x00000003 << cellShift4;

    // initial access
    uint4 nodeIndex4 = 0;
    uint4 vxsmAccess4 = vxsmOffset;

    // calculate bit
    uint4 childmask4 = uint4(
        _VxShadowMapsBuffer[vxsmAccess4.x],
        _VxShadowMapsBuffer[vxsmAccess4.y],
        _VxShadowMapsBuffer[vxsmAccess4.z],
        _VxShadowMapsBuffer[vxsmAccess4.w]) >> 16;
    uint4 shadowbit4 = (childmask4 & cellbit4) >> cellShift4;

    // determine whether it is intersected or not
    bool4 intersected4 = shadowbit4 == 0x00000003;

    uint4 mask4 = 0;
    uint4 childrenbit4 = 0;
    uint4 childIndex4 = 0;

    for (; scale > 3 && any(intersected4); --scale)
    {
        // find next child node
        mask4 = ~(0xFFFFFFFF << cellShift4);
        childrenbit4 = childmask4 & ((childmask4 & 0x0000AAAA) >> 1);
        childIndex4 = countBits_(childrenbit4 & mask4);

        // update access
        vxsmAccess4 = vxsmAccess4 + 1 + childIndex4;
        nodeIndex4 = uint4(
            _VxShadowMapsBuffer[vxsmAccess4.x],
            _VxShadowMapsBuffer[vxsmAccess4.y],
            _VxShadowMapsBuffer[vxsmAccess4.z],
            _VxShadowMapsBuffer[vxsmAccess4.w]);
        vxsmAccess4 = vxsmOffset + nodeIndex4;

        // calculate where to go to child
        uint scaleShift = scale - 1;
        childDet_0 = ((posQ_0 >> scaleShift) & 0x00000001) << uint3(1, 2, 3);
        childDet_1 = ((posQ_1 >> scaleShift) & 0x00000001) << uint3(1, 2, 3);
        childDet_2 = ((posQ_2 >> scaleShift) & 0x00000001) << uint3(1, 2, 3);
        childDet_3 = ((posQ_3 >> scaleShift) & 0x00000001) << uint3(1, 2, 3);
        cellShift4.x = childDet_0.x + childDet_0.y + childDet_0.z;
        cellShift4.y = childDet_1.x + childDet_1.y + childDet_1.z;
        cellShift4.z = childDet_2.x + childDet_2.y + childDet_2.z;
        cellShift4.w = childDet_3.x + childDet_3.y + childDet_3.z;
        cellbit4 = 0x00000003 << cellShift4;

        // calculate bit
        childmask4 = uint4(
            _VxShadowMapsBuffer[vxsmAccess4.x],
            _VxShadowMapsBuffer[vxsmAccess4.y],
            _VxShadowMapsBuffer[vxsmAccess4.z],
            _VxShadowMapsBuffer[vxsmAccess4.w]) >> 16;
        shadowbit4 = intersected4 ? (childmask4 & cellbit4) >> cellShift4 : shadowbit4;

        // determine whether it is intersected or not
        intersected4 = shadowbit4 == 0x00000003;
    }

    // go further the rest of computation
    if (any(intersected4))
    {
        mask4 = ~(0xFFFFFFFF << cellShift4);
        childrenbit4 = childmask4 & ((childmask4 & 0x0000AAAA) >> 1);
        childIndex4 = countBits_(childrenbit4 & mask4);

        vxsmAccess4 = vxsmAccess4 + 1 + childIndex4;
        nodeIndex4 = uint4(
            _VxShadowMapsBuffer[vxsmAccess4.x],
            _VxShadowMapsBuffer[vxsmAccess4.y],
            _VxShadowMapsBuffer[vxsmAccess4.z],
            _VxShadowMapsBuffer[vxsmAccess4.w]);
    }

    bool4 lit4      = shadowbit4 & 0x00000001;
    bool4 shadowed4 = shadowbit4 & 0x00000002;

    results[0] = uint4(nodeIndex4.x, lit4.x, shadowed4.x, intersected4.x);
    results[1] = uint4(nodeIndex4.y, lit4.y, shadowed4.y, intersected4.y);
    results[2] = uint4(nodeIndex4.z, lit4.z, shadowed4.z, intersected4.z);
    results[3] = uint4(nodeIndex4.w, lit4.w, shadowed4.w, intersected4.w);
#else
    uint vxsmOffset = begin + typeOffset;
    uint dagScale = _VxShadowMapsBuffer[begin + 2];

    uint3 posQ_1 = posQ_0 + uint3(1, 0, 0);
    uint3 posQ_2 = posQ_0 + uint3(0, 1, 0);
    uint3 posQ_3 = posQ_0 + uint3(1, 1, 0);

    uint4 nodeIndex4 = 0;
    uint scale = dagScale;

    bool4 lit4 = false;
    bool4 shadowed4 = false;
    bool4 intersected4 = true;

    for (; scale > 3 && any(intersected4); --scale)
    {
        // calculate where to go to child
        uint3 childDet_0 = (posQ_0 >> (scale - 1)) & 0x00000001;
        uint3 childDet_1 = (posQ_1 >> (scale - 1)) & 0x00000001;
        uint3 childDet_2 = (posQ_2 >> (scale - 1)) & 0x00000001;
        uint3 childDet_3 = (posQ_3 >> (scale - 1)) & 0x00000001;

        uint4 cellShift4 = uint4(
            (childDet_0.x << 1) + (childDet_0.y << 2) + (childDet_0.z << 3),
            (childDet_1.x << 1) + (childDet_1.y << 2) + (childDet_1.z << 3),
            (childDet_2.x << 1) + (childDet_2.y << 2) + (childDet_2.z << 3),
            (childDet_3.x << 1) + (childDet_3.y << 2) + (childDet_3.z << 3));

        uint4 cellbit4 = 0x00000003 << cellShift4;

        // calculate bit
        uint4 header4 = uint4(
            _VxShadowMapsBuffer[vxsmOffset + nodeIndex4.x],
            _VxShadowMapsBuffer[vxsmOffset + nodeIndex4.y],
            _VxShadowMapsBuffer[vxsmOffset + nodeIndex4.z],
            _VxShadowMapsBuffer[vxsmOffset + nodeIndex4.w]);
        uint4 childmask4 = header4 >> 16;
        uint4 shadowbit4 = (childmask4 & cellbit4) >> cellShift4;

        // determine whether it is lit or shadowed.
        lit4      = intersected4 ? shadowbit4 & 0x00000001 : lit4;
        shadowed4 = intersected4 ? shadowbit4 & 0x00000002 : shadowed4;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        intersected4 = lit4 && shadowed4;

        // find next child node
        uint4 mask4 = ~(0xFFFFFFFF << cellShift4);
        uint4 childrenbit4 = childmask4 & ((childmask4 & 0x0000AAAA) >> 1);
        uint4 childIndex4 = countBits(childrenbit4 & mask4);
        uint4 nextIndex4 = vxsmOffset + nodeIndex4 + 1 + childIndex4;

        // go down to the next node
        nodeIndex4.x = intersected4.x ? _VxShadowMapsBuffer[nextIndex4.x] : nodeIndex4.x;
        nodeIndex4.y = intersected4.y ? _VxShadowMapsBuffer[nextIndex4.y] : nodeIndex4.y;
        nodeIndex4.z = intersected4.z ? _VxShadowMapsBuffer[nextIndex4.z] : nodeIndex4.z;
        nodeIndex4.w = intersected4.w ? _VxShadowMapsBuffer[nextIndex4.w] : nodeIndex4.w;
    }

    results[0] = uint4(nodeIndex4.x, lit4.x, shadowed4.x, intersected4.x);
    results[1] = uint4(nodeIndex4.y, lit4.y, shadowed4.y, intersected4.y);
    results[2] = uint4(nodeIndex4.z, lit4.z, shadowed4.z, intersected4.z);
    results[3] = uint4(nodeIndex4.w, lit4.w, shadowed4.w, intersected4.w);
#endif
}

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void CSMain(uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    uint2 pixelCoord = groupId * TILE_SIZE + groupThreadId;
    uint2 tileCoord = groupId;

    if (any(pixelCoord.xy >= (uint2)_ScreenSize.xy))
        return;

    float depth = LOAD_TEXTURE2D(_CameraDepthTexture, pixelCoord).x;

    if (depth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        _ScreenSpaceShadowOutput[pixelCoord] = 1.0;
        return;
    }

    // if depth is not reversed
#if !UNITY_REVERSED_Z
    // todo : find the way to work on OpenGLES 3.1+ on mobile
    //depth = depth * 2.0 - 1.0; OpenGLCore
#endif

    PositionInputs posInput = GetPositionInput(pixelCoord.xy, _ScreenSize.zw, tileCoord);
    float3 positionWS = ComputeWorldSpacePosition(posInput.positionNDC, depth, UNITY_MATRIX_I_VP);

    float shadowStrength = GetMainLightShadowStrength();
    float attenuation = 1.0;

#if WITH_DYNAMIC_SHADOWS
    float4 shadowMapCoords = TransformWorldToShadowCoord(positionWS);

    ShadowSamplingData shadowSamplingData = GetMainLightShadowSamplingData();
    attenuation = SampleShadowmap(shadowMapCoords, TEXTURE2D_ARGS(_MainLightShadowmapTexture, sampler_MainLightShadowmapTexture), shadowSamplingData, 1.0, false);

    if (attenuation == 0.0)
    {
        attenuation = LerpWhiteTo(attenuation, shadowStrength);
        _ScreenSpaceShadowOutput[pixelCoord] = attenuation;
        return;
    }
#endif

    float volumeScale = asfloat(_VxShadowMapsBuffer[_BeginOffset + 1]);
    uint dagScale = _VxShadowMapsBuffer[_BeginOffset + 2];
    float4x4 worldToShadowMatrix =
    {
        asfloat(_VxShadowMapsBuffer[_BeginOffset +  3]),
        asfloat(_VxShadowMapsBuffer[_BeginOffset +  4]),
        asfloat(_VxShadowMapsBuffer[_BeginOffset +  5]),
        asfloat(_VxShadowMapsBuffer[_BeginOffset +  6]),

        asfloat(_VxShadowMapsBuffer[_BeginOffset +  7]),
        asfloat(_VxShadowMapsBuffer[_BeginOffset +  8]),
        asfloat(_VxShadowMapsBuffer[_BeginOffset +  9]),
        asfloat(_VxShadowMapsBuffer[_BeginOffset + 10]),

        asfloat(_VxShadowMapsBuffer[_BeginOffset + 11]),
        asfloat(_VxShadowMapsBuffer[_BeginOffset + 12]),
        asfloat(_VxShadowMapsBuffer[_BeginOffset + 13]),
        asfloat(_VxShadowMapsBuffer[_BeginOffset + 14]),

        0.0, 0.0, 0.0, 1.0,
    };

    uint voxelResolution = 1 << dagScale;
    float bias = (volumeScale / voxelResolution);

    positionWS.y += bias;

    float3 posNDC = mul(worldToShadowMatrix, float4(positionWS, 1.0)).xyz;
    float3 posP = posNDC * (float)voxelResolution;
    float3 posF = floor(posP);
    float3 lerpWeight = posP - posF;

    uint3 posQ = (uint3)posP;
    posQ.z -= 2;

    if (any(posQ >= (voxelResolution.xxx - 1)))
    {
        attenuation = LerpWhiteTo(attenuation, shadowStrength);
        _ScreenSpaceShadowOutput[pixelCoord] = attenuation;
        return;
    }

#if NEAREST_SAMPLE
    uint4 result;
    TraverseVxShadowMapPosQ_(_BeginOffset, OFFSET_DIR, posQ, result);

    if (result.w == 0)
    {
        attenuation = result.y ? attenuation : 0.0;
        attenuation = LerpWhiteTo(attenuation, shadowStrength);
        _ScreenSpaceShadowOutput[pixelCoord] = attenuation;
        return;
    }

    float attenuationVxsm = TraverseNearestSampleVxShadowMap(_BeginOffset, OFFSET_DIR, posQ, result);
    attenuation = min(attenuation, attenuationVxsm);
#elif BILINEAR_SAMPLE
    uint4 results[4];
    TraverseVxShadowMapPosQ2x2_(_BeginOffset, OFFSET_DIR, posQ, results);

    if (results[0].w == 0 && results[1].w == 0 && results[2].w == 0 && results[3].w == 0)
    {
        float4 attenuation4 = float4(
            results[0].y ? attenuation : 0.0,
            results[1].y ? attenuation : 0.0,
            results[2].y ? attenuation : 0.0,
            results[3].y ? attenuation : 0.0);
        attenuation4.xy = lerp(attenuation4.xz, attenuation4.yw, lerpWeight.x);

        attenuation = lerp(attenuation4.x, attenuation4.y, lerpWeight.y);
        attenuation = LerpWhiteTo(attenuation, shadowStrength);
        _ScreenSpaceShadowOutput[pixelCoord] = attenuation;
        return;
    }

    float attenuationVxsm = TraverseBilinearSampleVxShadowMap(_BeginOffset, OFFSET_DIR, posQ, results, lerpWeight.xy);
    attenuation = min(attenuation, attenuationVxsm);
#elif TRILINEAR_SAMPLE
    uint4 results[8];
    TraverseVxShadowMapPosQ2x2x2(_BeginOffset, OFFSET_DIR, posQ, results);

    if (results[0].w == 0 && results[1].w == 0 && results[2].w == 0 && results[3].w == 0 &&
        results[4].w == 0 && results[5].w == 0 && results[6].w == 0 && results[7].w == 0)
    {
        float4 attenuation4_0 = float4(
            results[0].y ? attenuation : 0.0,
            results[2].y ? attenuation : 0.0,
            results[4].y ? attenuation : 0.0,
            results[6].y ? attenuation : 0.0);
        float4 attenuation4_1 = float4(
            results[1].y ? attenuation : 0.0,
            results[3].y ? attenuation : 0.0,
            results[5].y ? attenuation : 0.0,
            results[7].y ? attenuation : 0.0);

        attenuation4_0    = lerp(attenuation4_0, attenuation4_1, lerpWeight.x);
        attenuation4_0.xy = lerp(attenuation4_0.xz, attenuation4_0.yw, lerpWeight.y);

        attenuation = lerp(attenuation4_0.x, attenuation4_0.y, lerpWeight.z);
        attenuation = LerpWhiteTo(attenuation, shadowStrength);
        _ScreenSpaceShadowOutput[pixelCoord] = attenuation;
        return;
    }

    float attenuationVxsm = TravereTrilinearSampleVxShadowMap(_BeginOffset, OFFSET_DIR, posQ, results, lerpWeight);
    attenuation = min(attenuation, attenuationVxsm);
#endif

    attenuation = LerpWhiteTo(attenuation, shadowStrength);
    _ScreenSpaceShadowOutput[pixelCoord] = attenuation;
}
